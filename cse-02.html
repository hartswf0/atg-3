<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ATG 2.2 | Node Topographies</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap');

        :root {
            --bg-deep: #020617;
            --bg-card: #050509;
            --border-card: #27272a;
            --accent-orange: #f97316;
            --accent-teal: #14b8a6;
            --accent-purple: #a855f7;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: radial-gradient(circle at top, #111827 0, #020617 40%, #000 90%);
            color: #e5e5e5;
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
        }

        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }

        .project-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 16px;
            padding: 16px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .project-card {
            background: radial-gradient(circle at 0 0, #27272a 0, #050505 50%, #020617 100%);
            border: 1px solid var(--border-card);
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: border-color 0.25s, box-shadow 0.25s, transform 0.2s;
        }

        .project-card:hover {
            border-color: #4b5563;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.7);
            transform: translateY(-1px);
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
            background: var(--bg-deep);
            overflow: hidden;
            border-bottom: 1px solid rgba(15, 23, 42, 0.9);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .scanlines {
            position: absolute;
            inset: 0;
            background:
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.28) 50%),
                linear-gradient(90deg, rgba(248, 113, 22, 0.08), rgba(20, 184, 166, 0.02), rgba(168, 85, 247, 0.08));
            background-size: 100% 4px, 3px 100%;
            mix-blend-mode: soft-light;
            pointer-events: none;
            opacity: 0.5;
        }

        .axis-labels {
            position: absolute;
            inset: 0;
            pointer-events: none;
            font-size: 9px;
            font-family: 'JetBrains Mono', monospace;
            color: rgba(226, 232, 240, 0.25);
            text-transform: uppercase;
        }

        .axis-labels div {
            position: absolute;
            white-space: nowrap;
        }

        .focus-chip {
            position: absolute;
            top: 8px;
            left: 8px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.96);
            border: 1px solid rgba(148, 163, 184, 0.45);
            color: rgba(226, 232, 240, 0.9);
            pointer-events: none;
        }

        .focus-swatch {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            box-shadow: 0 0 10px currentColor;
        }

        .tap-hint {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 9px;
            font-family: 'JetBrains Mono', monospace;
            color: rgba(148, 163, 184, 0.9);
            letter-spacing: 0.12em;
            text-transform: uppercase;
            background: rgba(15, 23, 42, 0.96);
            border-radius: 999px;
            padding: 2px 8px;
            border: 1px dashed rgba(148, 163, 184, 0.4);
        }

        .ping {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 999px;
            border: 1px solid rgba(248, 250, 252, 0.7);
            pointer-events: none;
            animation: ping 0.7s ease-out forwards;
            mix-blend-mode: screen;
        }

        @keyframes ping {
            0% {
                transform: translate(-50%, -50%) scale(0.4);
                opacity: 0.9;
            }

            100% {
                transform: translate(-50%, -50%) scale(2.4);
                opacity: 0;
            }
        }

        .meta-section {
            padding: 12px 14px 14px 14px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .meta-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 11px;
        }

        .meta-label {
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            font-size: 9px;
        }

        .meta-value {
            color: #e5e7eb;
            font-weight: 500;
            text-align: right;
        }

        .phase-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background: rgba(15, 23, 42, 0.92);
            border-radius: 999px;
            color: #d4d4d8;
            font-size: 9px;
            border: 1px solid rgba(148, 163, 184, 0.55);
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }

        .phase-dot {
            width: 6px;
            height: 6px;
            border-radius: 999px;
            background: #22c55e;
            box-shadow: 0 0 8px #22c55e;
        }

        header h1 {
            letter-spacing: 0.24em;
        }
    </style>
</head>

<body>
    <header
        class="p-4 md:p-6 border-b border-neutral-900 flex justify-between items-center bg-black/60 backdrop-blur sticky top-0 z-50">
        <div class="flex items-center gap-3">
            <div
                class="w-8 h-8 rounded-full border border-neutral-700 flex items-center justify-center bg-neutral-900 shadow-lg shadow-black/50">
                <i data-lucide="activity" class="w-4 h-4 text-orange-400"></i>
            </div>
            <div>
                <h1 class="text-sm md:text-base font-semibold tracking-[0.24em] uppercase text-slate-50">
                    ATG 2.2
                    <span class="text-[10px] font-mono text-neutral-500 tracking-[0.26em] ml-2">NODE TOPOGRAPHIES</span>
                </h1>
            </div>
        </div>
        <div class="hidden md:flex gap-2 text-[9px] font-mono tracking-[0.15em] text-neutral-500 uppercase">
            <span class="flex items-center gap-1"><span
                    class="w-2 h-2 rounded-full bg-[var(--accent-orange)]"></span>Arch</span>
            <span class="flex items-center gap-1"><span
                    class="w-2 h-2 rounded-full bg-[var(--accent-teal)]"></span>Alch</span>
            <span class="flex items-center gap-1"><span
                    class="w-2 h-2 rounded-full bg-[var(--accent-purple)]"></span>Arc</span>
        </div>
    </header>

    <div class="project-grid" id="grid-container"></div>

    <script>
        (function () {
            lucide.createIcons();

            const CONFIG = {
                LOGICAL_SIZE: 48,
                RENDER_RES: 96,
                AGENTS: [
                    { id: 'arch', name: 'ARCH', color: '#f97316', trait: 'direct' },  // orange
                    { id: 'alch', name: 'ALCH', color: '#14b8a6', trait: 'wander' },  // teal
                    { id: 'arcv', name: 'ARC', color: '#a855f7', trait: 'loop' }     // purple
                ]
            };

            // --- URL GROUPS → CARDS ---
            const PROJECTS = [
                {
                    title: "DIRTY DISCLOSURE",
                    root: "dirty-disclosure",
                    status: "LIVE",
                    densityHint: 0.7,
                    nodes: [
                        {
                            id: "dirty",
                            label: "DIRTY",
                            x: 0.5,
                            y: 0.5,
                            url: "https://hartswf0.github.io/dirty-disclosure/"
                        }
                    ]
                },
                {
                    title: "PRIVACY VALUE LABELS",
                    root: "privacy-value-labels",
                    status: "LIVE",
                    densityHint: 0.6,
                    nodes: [
                        {
                            id: "pvl",
                            label: "PVL",
                            x: 0.5,
                            y: 0.45,
                            url: "https://hartswf0.github.io/privacy-value-labels/#view=label"
                        }
                    ]
                },
                {
                    title: "MFSS",
                    root: "mfss",
                    status: "LIVE",
                    densityHint: 0.5,
                    nodes: [
                        {
                            id: "mfss",
                            label: "MFSS",
                            x: 0.52,
                            y: 0.52,
                            url: "https://hartswf0.github.io/mfss/"
                        }
                    ]
                },
                {
                    title: "ROLE DECK",
                    root: "role-deck",
                    status: "HUB",
                    densityHint: 0.8,
                    nodes: [
                        {
                            id: "role-root",
                            label: "ROLE",
                            x: 0.28,
                            y: 0.42,
                            url: "https://hartswf0.github.io/role-deck/"
                        },
                        {
                            id: "role-hub",
                            label: "HUB",
                            x: 0.72,
                            y: 0.64,
                            url: "https://hartswf0.github.io/role-deck/HUB.html"
                        }
                    ]
                },
                {
                    title: "LIBERTY MACHINES",
                    root: "liberty-machines",
                    status: "LIVE",
                    densityHint: 0.66,
                    nodes: [
                        {
                            id: "lib",
                            label: "LIB",
                            x: 0.52,
                            y: 0.5,
                            url: "https://hartswf0.github.io/liberty-machines/"
                        }
                    ]
                },
                {
                    title: "FUNC-SUB",
                    root: "func-sub",
                    status: "ITERATE",
                    densityHint: 0.75,
                    nodes: [
                        {
                            id: "func-index",
                            label: "INDEX",
                            x: 0.3,
                            y: 0.4,
                            url: "https://hartswf0.github.io/func-sub/func-index.html"
                        },
                        {
                            id: "func-t6",
                            label: "T6",
                            x: 0.7,
                            y: 0.6,
                            url: "https://hartswf0.github.io/func-sub/t6-sonic.html"
                        }
                    ]
                },
                {
                    title: "1000 SMALL FUTURES",
                    root: "1000-small-futures",
                    status: "LIVE",
                    densityHint: 0.55,
                    nodes: [
                        {
                            id: "1k",
                            label: "1K",
                            x: 0.52,
                            y: 0.48,
                            url: "https://hartswf0.github.io/1000-small-futures/"
                        }
                    ]
                },
                {
                    title: "THE FORK",
                    root: "the-fork",
                    status: "LIVE",
                    densityHint: 0.62,
                    nodes: [
                        {
                            id: "fork",
                            label: "FORK",
                            x: 0.52,
                            y: 0.52,
                            url: "https://hartswf0.github.io/the-fork/"
                        }
                    ]
                },
                {
                    title: "TRACTOR · DCE·GYO",
                    root: "tractor-dce-gyo",
                    status: "PAIR",
                    densityHint: 0.7,
                    nodes: [
                        {
                            id: "wag-work",
                            label: "WORK",
                            x: 0.32,
                            y: 0.46,
                            url: "https://hartswf0.github.io/tractor-dce-gyo/wag-work.html"
                        },
                        {
                            id: "wag-pres",
                            label: "PRES",
                            x: 0.72,
                            y: 0.62,
                            url: "https://hartswf0.github.io/tractor-dce-gyo/wag-pres.html"
                        }
                    ]
                }
            ];

            class Agent {
                constructor(config, nodes) {
                    this.id = config.id;
                    this.name = config.name;
                    this.color = config.color;
                    this.trait = config.trait;
                    this.nodes = nodes;

                    this.pos = { x: Math.random(), y: Math.random() };
                    this.target = null;
                    this.history = [];
                    this.state = 'idle';
                    this.wait = Math.random() * 40 + 20;
                }

                pickTarget(attractors) {
                    if (attractors && attractors.length) {
                        const chosen = attractors[Math.floor(Math.random() * attractors.length)];
                        this.target = { x: chosen.x, y: chosen.y, node: null };
                    } else if (this.nodes && this.nodes.length) {
                        const n = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                        this.target = { x: n.x, y: n.y, node: n };
                    }
                    this.state = 'moving';
                }

                update(heatGrid, gridSize, attractors) {
                    if (this.state === 'idle') {
                        this.wait--;
                        if (this.wait <= 0) this.pickTarget(attractors);
                        return;
                    }
                    if (!this.target) return;

                    const tx = this.target.x;
                    const ty = this.target.y;

                    let dx = tx - this.pos.x;
                    let dy = ty - this.pos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;

                    if (dist < 0.015) {
                        this.state = 'idle';
                        this.wait = 25 + Math.random() * 60;
                        this.deposit(heatGrid, gridSize, 0.09, 0.35);
                        return;
                    }

                    dx /= dist; dy /= dist;

                    const t = Date.now() * 0.0018;
                    let noiseX = 0, noiseY = 0;
                    if (this.trait === 'wander') {
                        noiseX = Math.sin(t * 1.7 + this.id.length) * 0.7;
                        noiseY = Math.cos(t * 1.3 + this.id.length * 1.9) * 0.7;
                    } else if (this.trait === 'loop') {
                        noiseX = Math.sin(t + this.id.length) * 0.3;
                        noiseY = Math.cos(t * 0.9 + this.id.length * 2.1) * 0.3;
                    }

                    const speed = 0.0028;
                    this.pos.x += (dx + noiseX * 0.4) * speed;
                    this.pos.y += (dy + noiseY * 0.4) * speed;

                    this.pos.x = Math.max(0, Math.min(1, this.pos.x));
                    this.pos.y = Math.max(0, Math.min(1, this.pos.y));

                    this.deposit(heatGrid, gridSize, 0.02, 0.05);

                    this.history.push({ x: this.pos.x, y: this.pos.y });
                    if (this.history.length > 36) this.history.shift();
                }

                deposit(grid, size, radiusNorm, val) {
                    const gx = this.pos.x * size;
                    const gy = this.pos.y * size;
                    const r = radiusNorm * size;
                    const r2 = r * r;

                    const minX = Math.max(0, Math.floor(gx - r));
                    const maxX = Math.min(size - 1, Math.ceil(gx + r));
                    const minY = Math.max(0, Math.floor(gy - r));
                    const maxY = Math.min(size - 1, Math.ceil(gy + r));

                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            const dx = x - gx;
                            const dy = y - gy;
                            if (dx * dx + dy * dy < r2) {
                                const idx = y * size + x;
                                grid[idx] = Math.min(grid[idx] + val * 0.1, 1.3);
                            }
                        }
                    }
                }
            }

            class TerrainSimulation {
                constructor(container, data) {
                    this.container = container;
                    this.data = data;
                    this.width = 0;
                    this.height = 0;

                    this.heatGrid = new Float32Array(CONFIG.LOGICAL_SIZE * CONFIG.LOGICAL_SIZE);
                    this.renderGrid = new Float32Array(CONFIG.RENDER_RES * CONFIG.RENDER_RES);

                    this.agents = CONFIG.AGENTS.map(cfg => new Agent(cfg, this.data.nodes));
                    this.attractors = [];
                    this.focusIndex = -1;
                    this.focusAgent = null;

                    this.setupDOM();
                    this.setupCanvas();

                    this.resizeObserver = new ResizeObserver(() => this.resize());
                    this.resizeObserver.observe(this.container.querySelector('.canvas-wrapper'));

                    this.loop();
                }

                setupDOM() {
                    this.container.innerHTML = `
                    <div class="canvas-wrapper">
                        <canvas></canvas>
                        <div class="scanlines"></div>
                        <div class="axis-labels">
                            <div style="bottom:6px; left:50%; transform:translateX(-50%);">PHASE →</div>
                            <div style="left:6px; top:50%; transform:translateY(-50%) rotate(-90deg);">LOAD →</div>
                        </div>
                        <div class="focus-chip">
                            <span class="focus-swatch"></span>
                            <span class="focus-label font-mono">ALL</span>
                        </div>
                        <div class="tap-hint font-mono">CLICK TERRAIN · NODE = OPEN</div>
                    </div>
                    <div class="meta-section">
                        <div class="flex justify-between items-center">
                            <div>
                                <h2 class="text-[11px] font-semibold tracking-[0.18em] uppercase text-slate-50">${this.data.title}</h2>
                                <p class="text-[9px] text-neutral-500 mt-1 font-mono">${this.data.root}</p>
                            </div>
                            <span class="phase-pill">
                                <span class="phase-dot"></span>${this.data.status}
                            </span>
                        </div>
                        <div class="meta-row">
                            <span class="meta-label">Flux</span>
                            <span class="meta-value font-mono text-orange-400" id="flux-val">0.00</span>
                        </div>
                        <div class="meta-row">
                            <span class="meta-label">Depth</span>
                            <span class="meta-value font-mono text-teal-300" id="depth-val">0.00</span>
                        </div>
                        <div class="meta-row">
                            <span class="meta-label">Pages</span>
                            <span class="meta-value font-mono text-purple-300" id="pages-val">${this.data.nodes.length}</span>
                        </div>
                    </div>
                `;

                    this.canvas = this.container.querySelector('canvas');
                    this.ctx = this.canvas.getContext('2d');

                    this.fluxEl = this.container.querySelector('#flux-val');
                    this.depthEl = this.container.querySelector('#depth-val');
                    this.focusLabelEl = this.container.querySelector('.focus-label');
                    this.focusSwatchEl = this.container.querySelector('.focus-swatch');

                    this.canvas.addEventListener('click', (e) => this.onClick(e));
                }

                setupCanvas() {
                    const rect = this.container.querySelector('.canvas-wrapper').getBoundingClientRect();
                    this.width = rect.width;
                    this.height = rect.height;
                    const dpr = Math.min(window.devicePixelRatio || 1, 2);
                    this.canvas.width = this.width * dpr;
                    this.canvas.height = this.height * dpr;
                    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }

                resize() {
                    this.setupCanvas();
                }

                cycleFocus() {
                    this.focusIndex++;
                    if (this.focusIndex >= CONFIG.AGENTS.length) {
                        this.focusIndex = -1;
                        this.focusAgent = null;
                        this.focusLabelEl.textContent = 'ALL';
                        this.focusSwatchEl.style.background = '#94a3b8';
                        this.focusSwatchEl.style.boxShadow = '0 0 10px #94a3b8';
                    } else {
                        this.focusAgent = CONFIG.AGENTS[this.focusIndex];
                        this.focusLabelEl.textContent = this.focusAgent.name;
                        this.focusSwatchEl.style.background = this.focusAgent.color;
                        this.focusSwatchEl.style.boxShadow = `0 0 10px ${this.focusAgent.color}`;
                    }
                }

                onClick(e) {
                    const rect = this.canvas.getBoundingClientRect();
                    const px = e.clientX - rect.left;
                    const py = e.clientY - rect.top;
                    const xNorm = px / rect.width;
                    const yNorm = py / rect.height;

                    // Check if click is near a node → open URL
                    const radiusPx = 14;
                    let opened = false;
                    for (const n of this.data.nodes) {
                        const nx = n.x * this.width;
                        const ny = n.y * this.height;
                        const dx = px - nx;
                        const dy = py - ny;
                        if (dx * dx + dy * dy <= radiusPx * radiusPx) {
                            window.open(n.url, '_blank', 'noopener,noreferrer');
                            opened = true;
                            break;
                        }
                    }

                    // Always drop attractor + ping
                    this.attractors.push({ x: xNorm, y: yNorm, life: 220 });

                    const ping = document.createElement('div');
                    ping.className = 'ping';
                    ping.style.left = `${xNorm * 100}%`;
                    ping.style.top = `${yNorm * 100}%`;
                    this.container.querySelector('.canvas-wrapper').appendChild(ping);
                    setTimeout(() => ping.remove(), 700);

                    // Cycle focus only when clicking terrain (not just node)? Up to you.
                    // Here we always cycle to keep it playful.
                    this.cycleFocus();
                }

                update() {
                    this.agents.forEach(agent => agent.update(this.heatGrid, CONFIG.LOGICAL_SIZE, this.attractors));

                    for (let i = 0; i < this.heatGrid.length; i++) {
                        this.heatGrid[i] *= 0.995;
                    }

                    // Attractors deposit extra heat then decay
                    this.attractors = this.attractors.filter(a => {
                        a.life -= 2;
                        if (a.life <= 0) return false;

                        const size = CONFIG.LOGICAL_SIZE;
                        const gx = a.x * size;
                        const gy = a.y * size;
                        const r = 0.06 * size;
                        const r2 = r * r;

                        const minX = Math.max(0, Math.floor(gx - r));
                        const maxX = Math.min(size - 1, Math.ceil(gx + r));
                        const minY = Math.max(0, Math.floor(gy - r));
                        const maxY = Math.min(size - 1, Math.ceil(gy + r));

                        for (let y = minY; y <= maxY; y++) {
                            for (let x = minX; x <= maxX; x++) {
                                const dx = x - gx;
                                const dy = y - gy;
                                if (dx * dx + dy * dy < r2) {
                                    const idx = y * size + x;
                                    this.heatGrid[idx] = Math.min(this.heatGrid[idx] + 0.08, 1.4);
                                }
                            }
                        }

                        return true;
                    });

                    // Upscale to render grid
                    const scale = (CONFIG.LOGICAL_SIZE - 1) / (CONFIG.RENDER_RES - 1);
                    for (let y = 0; y < CONFIG.RENDER_RES; y++) {
                        for (let x = 0; x < CONFIG.RENDER_RES; x++) {
                            const gx = x * scale;
                            const gy = y * scale;
                            const ix = Math.floor(gx);
                            const iy = Math.floor(gy);
                            const fx = gx - ix;
                            const fy = gy - iy;
                            const baseIdx = iy * CONFIG.LOGICAL_SIZE + ix;
                            if (baseIdx + CONFIG.LOGICAL_SIZE + 1 >= this.heatGrid.length) continue;

                            const v00 = this.heatGrid[baseIdx];
                            const v10 = this.heatGrid[baseIdx + 1];
                            const v01 = this.heatGrid[baseIdx + CONFIG.LOGICAL_SIZE];
                            const v11 = this.heatGrid[baseIdx + CONFIG.LOGICAL_SIZE + 1];

                            const top = v00 * (1 - fx) + v10 * fx;
                            const bot = v01 * (1 - fx) + v11 * fx;
                            this.renderGrid[y * CONFIG.RENDER_RES + x] = top * (1 - fy) + bot * fy;
                        }
                    }

                    // Occasionally update flux/depth readout
                    if (Math.random() < 0.08) {
                        let sum = 0, max = 0;
                        for (let i = 0; i < this.heatGrid.length; i++) {
                            const v = this.heatGrid[i];
                            sum += v;
                            if (v > max) max = v;
                        }
                        const avg = sum / this.heatGrid.length;
                        this.fluxEl.textContent = avg.toFixed(2);
                        this.depthEl.textContent = max.toFixed(2);
                    }
                }

                draw() {
                    this.ctx.fillStyle = '#020617';
                    this.ctx.fillRect(0, 0, this.width, this.height);

                    const cellW = this.width / CONFIG.RENDER_RES;
                    const cellH = this.height / CONFIG.RENDER_RES;

                    // Heat layer
                    for (let y = 0; y < CONFIG.RENDER_RES; y++) {
                        for (let x = 0; x < CONFIG.RENDER_RES; x++) {
                            const val = this.renderGrid[y * CONFIG.RENDER_RES + x];
                            if (val < 0.03) continue;

                            const intensity = Math.min(val * 1.4, 1.0);
                            const r = 70 + intensity * 190;
                            const g = 40 + intensity * 70;
                            const b = 30 + intensity * 50;
                            const a = intensity * 0.45;
                            this.ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
                            this.ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
                        }
                    }

                    // Contour-ish structure
                    const levels = 7;
                    for (let y = 0; y < CONFIG.RENDER_RES - 1; y++) {
                        for (let x = 0; x < CONFIG.RENDER_RES - 1; x++) {
                            const val = this.renderGrid[y * CONFIG.RENDER_RES + x];
                            if (val < 0.06) continue;
                            const lvl = Math.floor(val * levels);
                            const right = this.renderGrid[y * CONFIG.RENDER_RES + x + 1] || val;
                            const down = this.renderGrid[(y + 1) * CONFIG.RENDER_RES + x] || val;
                            const isEdge = Math.floor(right * levels) !== lvl || Math.floor(down * levels) !== lvl;
                            if (!isEdge) continue;
                            const c = 90 + (lvl / levels) * 110;
                            this.ctx.fillStyle = `rgba(${c},${c},${c},${0.18 + (lvl / levels) * 0.4})`;
                            this.ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
                        }
                    }

                    // Nodes = your sites
                    this.data.nodes.forEach(n => {
                        const x = n.x * this.width;
                        const y = n.y * this.height;

                        this.ctx.strokeStyle = 'rgba(148,163,184,0.55)';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 8, 0, Math.PI * 2);
                        this.ctx.stroke();

                        this.ctx.fillStyle = 'rgba(15,23,42,0.96)';
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3.2, 0, Math.PI * 2);
                        this.ctx.fill();

                        this.ctx.font = '9px JetBrains Mono';
                        this.ctx.fillStyle = 'rgba(226,232,240,0.8)';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(n.label, x, y + 16);
                    });

                    // Agents = collaborative activity field
                    const focusId = this.focusAgent ? this.focusAgent.id : null;
                    this.agents.forEach(agent => {
                        const isFocus = !focusId || focusId === agent.id;
                        const trailAlpha = isFocus ? 0.7 : 0.12;
                        const headAlpha = isFocus ? 1.0 : 0.35;
                        const widthScale = isFocus ? 1.6 : 0.8;

                        if (agent.history.length > 1) {
                            this.ctx.lineWidth = widthScale;
                            this.ctx.strokeStyle = agent.color;
                            for (let i = 0; i < agent.history.length - 1; i++) {
                                const p1 = agent.history[i];
                                const p2 = agent.history[i + 1];
                                const t = i / agent.history.length;
                                this.ctx.globalAlpha = trailAlpha * t;
                                this.ctx.beginPath();
                                this.ctx.moveTo(p1.x * this.width, p1.y * this.height);
                                this.ctx.lineTo(p2.x * this.width, p2.y * this.height);
                                this.ctx.stroke();
                            }
                            this.ctx.globalAlpha = 1.0;
                        }

                        const x = agent.pos.x * this.width;
                        const y = agent.pos.y * this.height;
                        const pulse = 3 + Math.sin(Date.now() * 0.004 + agent.id.length) * 1.1;

                        this.ctx.globalAlpha = headAlpha;
                        this.ctx.shadowBlur = isFocus ? 12 : 6;
                        this.ctx.shadowColor = agent.color;
                        this.ctx.fillStyle = agent.color;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, pulse * 0.9, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                        this.ctx.globalAlpha = 1.0;
                    });
                }

                loop() {
                    this.update();
                    this.draw();
                    requestAnimationFrame(() => this.loop());
                }
            }

            function init() {
                const grid = document.getElementById('grid-container');
                PROJECTS.forEach(project => {
                    const card = document.createElement('div');
                    card.className = 'project-card';
                    grid.appendChild(card);
                    new TerrainSimulation(card, project);
                });
            }

            window.addEventListener('load', init);
        })();
    </script>
</body>

</html>